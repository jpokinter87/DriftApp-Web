---
phase: 02-refactoring
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - services/motor_service.py
  - tests/test_motor_service.py
autonomous: true

must_haves:
  truths:
    - "Command dispatch uses registry dict instead of if/elif chain"
    - "Adding new command type only requires adding to registry dict"
    - "Existing command behavior unchanged"
    - "All motor service tests pass"
  artifacts:
    - path: "services/motor_service.py"
      provides: "OCP-compliant command dispatch via _command_registry dict"
      contains: "_command_registry"
  key_links:
    - from: "services/motor_service.py:process_command"
      to: "_command_registry"
      via: "handler lookup"
      pattern: "_command_registry.get\\(cmd_type\\)"
---

<objective>
Refactor MotorService.process_command() to use a command registry pattern for OCP compliance.

Purpose: Enable adding new command types without modifying process_command() - Open/Closed Principle.
Output: OCP-compliant command dispatch, cleaner code structure.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-refactoring/02-CONTEXT.md
@.planning/phases/02-refactoring/02-RESEARCH.md
@.planning/phases/01-code-review/reports/solid-report.md
@services/motor_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement command registry in MotorService</name>
  <files>services/motor_service.py</files>
  <action>
Refactor `MotorService` class to use command registry pattern:

**Step 1: Add command handler methods**

Create private handler methods for each command type (if not already extracted):
```python
def _handle_goto(self, command: Dict[str, Any]) -> None:
    """Handle GOTO command."""
    angle = command.get('angle', 0)
    speed = command.get('speed')
    self.current_status = self.goto_handler.execute(angle, self.current_status, speed)

def _handle_jog(self, command: Dict[str, Any]) -> None:
    """Handle JOG command."""
    delta = command.get('delta', 0)
    speed = command.get('speed')
    self.current_status = self.jog_handler.execute(delta, self.current_status, speed)

def _handle_continuous(self, command: Dict[str, Any]) -> None:
    """Handle CONTINUOUS movement command."""
    direction = command.get('direction')
    speed = command.get('speed')
    self.current_status = self.continuous_handler.execute(direction, self.current_status, speed)

def _handle_tracking_start(self, command: Dict[str, Any]) -> None:
    """Handle TRACKING_START command."""
    # ... existing tracking start logic

def _handle_tracking_stop(self, command: Dict[str, Any]) -> None:
    """Handle TRACKING_STOP command."""
    # ... existing tracking stop logic

def _handle_status(self, command: Dict[str, Any]) -> None:
    """Handle STATUS request (no-op, status already updated)."""
    pass
```

**Step 2: Create command registry in __init__ or _init_handlers**

Add after handler initialization:
```python
# Command registry for OCP-compliant dispatch
self._command_registry: Dict[str, Callable[[Dict[str, Any]], None]] = {
    'goto': self._handle_goto,
    'jog': self._handle_jog,
    'stop': self.handle_stop,
    'continuous': self._handle_continuous,
    'tracking_start': self._handle_tracking_start,
    'tracking_stop': self._handle_tracking_stop,
    'status': self._handle_status,
}
```

**Step 3: Refactor process_command()**

Replace the if/elif chain with registry lookup:
```python
def process_command(self, command: Dict[str, Any]) -> None:
    """Process a command from IPC (OCP compliant via registry)."""
    cmd_type = command.get('command', command.get('type'))

    if not cmd_type:
        logger.warning(f"Commande invalide (type manquant): {command}")
        return

    logger.info(f"Traitement commande: {cmd_type}")

    handler = self._command_registry.get(cmd_type)
    if handler:
        handler(command)
    else:
        logger.warning(f"Commande inconnue: {cmd_type}")

    # Clear command after processing
    self.ipc.clear_command()
```

Add typing import if not present: `from typing import Callable`
  </action>
  <verify>
Run: `uv run pytest tests/test_motor_service.py -v`
Run: `uv run pytest tests/test_command_handlers.py -v`
All tests pass.
  </verify>
  <done>
process_command() uses registry lookup instead of if/elif.
Handler methods extracted for each command type.
Tests pass with identical behavior.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify OCP compliance and add test</name>
  <files>tests/test_motor_service.py</files>
  <action>
Add a test to verify the registry pattern works correctly:

```python
def test_command_registry_contains_all_commands():
    """Verify command registry is complete (OCP pattern)."""
    # Create service with mocked dependencies
    service = create_test_motor_service()  # Use existing test fixture

    expected_commands = {'goto', 'jog', 'stop', 'continuous', 'tracking_start', 'tracking_stop', 'status'}
    actual_commands = set(service._command_registry.keys())

    assert expected_commands == actual_commands, f"Missing commands: {expected_commands - actual_commands}"

def test_unknown_command_logs_warning(caplog):
    """Verify unknown commands are handled gracefully."""
    service = create_test_motor_service()

    service.process_command({'command': 'unknown_command'})

    assert "Commande inconnue: unknown_command" in caplog.text
```

Adapt fixtures/mocks to match existing test patterns in the file.
  </action>
  <verify>
Run: `uv run pytest tests/test_motor_service.py::test_command_registry_contains_all_commands -v`
Run: `uv run pytest tests/test_motor_service.py::test_unknown_command_logs_warning -v`
Both tests pass.
  </verify>
  <done>
Tests verify registry completeness and unknown command handling.
OCP compliance is testable.
  </done>
</task>

<task type="auto">
  <name>Task 3: Commit SOLID changes</name>
  <files>.planning/phases/02-refactoring/CHANGELOG.md</files>
  <action>
Update `.planning/phases/02-refactoring/CHANGELOG.md` to add:

```markdown
### Changed (SOLID - OCP)
- `services/motor_service.py`: Refactored process_command() to use command registry pattern
  - Extracted handler methods: _handle_goto, _handle_jog, _handle_continuous, etc.
  - Added _command_registry dict for O(1) command dispatch
  - Adding new commands now only requires registry entry (OCP compliant)
- `tests/test_motor_service.py`: Added tests for registry pattern
```

Then commit with message:
```
refactor(02-03): implement command registry pattern (OCP)

- Extract _handle_* methods for each command type
- Add _command_registry dict for command dispatch
- Replace if/elif chain with registry lookup in process_command()
- Add tests for registry completeness and unknown commands

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
```
  </action>
  <verify>
Run: `git log -1 --oneline` shows the SOLID commit
CHANGELOG.md updated with SOLID changes
  </verify>
  <done>
SOLID/OCP changes committed.
CHANGELOG.md documents command registry refactoring.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_motor_service.py tests/test_command_handlers.py -v` - All tests pass
2. `grep -n "_command_registry" services/motor_service.py` - Registry exists
3. Cyclomatic complexity of process_command reduced (can verify with radon)
4. No if/elif chain for command types in process_command()
</verification>

<success_criteria>
- process_command() uses _command_registry dict lookup
- Each command has extracted _handle_* method
- Adding new command = adding to registry only (OCP)
- All motor service tests pass
- CHANGELOG.md documents changes
- Commit created with descriptive message
</success_criteria>

<output>
After completion, create `.planning/phases/02-refactoring/02-03-SUMMARY.md`
</output>
